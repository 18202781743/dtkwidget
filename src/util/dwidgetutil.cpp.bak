// SPDX-FileCopyrightText: 2017 - 2023 UnionTech Software Technology Co., Ltd.
//
// SPDX-License-Identifier: LGPL-3.0-or-later

#include "dwidgetutil.h"
#include <QWidget>
#include <QPixmap>
#include <QPainter>
#include <QPainterPath>
#include <QTextLayout>
#include <QApplication>
#include <QLoggingCategory>
#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
#include <QDesktopWidget>
#endif

QT_BEGIN_NAMESPACE
//extern Q_WIDGETS_EXPORT void qt_blurImage(QImage &blurImage, qreal radius, bool quality, int transposed = 0);
extern Q_WIDGETS_EXPORT void qt_blurImage(QPainter *p, QImage &blurImage, qreal radius, bool quality, bool alphaOnly, int transposed = 0);
QT_END_NAMESPACE

DWIDGET_BEGIN_NAMESPACE

Q_DECLARE_LOGGING_CATEGORY(logUtilClasses)

QImage dropShadow(const QPixmap &px, qreal radius, const QColor &color)
{
    qCDebug(logUtilClasses) << "dropShadow called with radius:" << radius 
                            << "color:" << color.name();
    if (px.isNull()) {
        qCDebug(logUtilClasses) << "pixmap is null, returning empty image";
        return QImage();
    }

    QSize size = px.size();
    qCDebug(logUtilClasses) << "processing pixmap with size:" << size;

    QImage tmp(size + QSize(radius * 2, radius * 2), QImage::Format_ARGB32_Premultiplied);
    tmp.fill(0);
    QPainter tmpPainter(&tmp);
    tmpPainter.setCompositionMode(QPainter::CompositionMode_Source);
    tmpPainter.drawPixmap(QPoint(radius, radius), px);
    tmpPainter.end();

    // blur the alpha channel
    qCDebug(logUtilClasses) << "blurring alpha channel";
    QImage blurred(tmp.size(), QImage::Format_ARGB32_Premultiplied);
    blurred.fill(0);
    QPainter blurPainter(&blurred);
    qt_blurImage(&blurPainter, tmp, radius, false, true);
    blurPainter.end();

    if (color == QColor(Qt::black)) {
        qCDebug(logUtilClasses) << "color is black, returning blurred image";
        return blurred;
    }

    qCDebug(logUtilClasses) << "applying color to blurred image";
    tmp = blurred;

    // blacken the image...
    tmpPainter.begin(&tmp);
    tmpPainter.setCompositionMode(QPainter::CompositionMode_SourceIn);
    tmpPainter.fillRect(tmp.rect(), color);
    tmpPainter.end();

    return tmp;
}

void moveToCenter(QWidget *w)
{
    qCDebug(logUtilClasses) << "moveToCenter called for widget:" << (w ? w->objectName() : "null");
    Q_ASSERT(w != nullptr);
#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
    QDesktopWidget *dw = QApplication::desktop();
    QRect parentRect = dw->availableGeometry(dw->primaryScreen());
#else
    auto parentRect = QGuiApplication::primaryScreen()->availableGeometry();
#endif

    if (w->parentWidget()) {
        qCDebug(logUtilClasses) << "using parent widget geometry";
        parentRect = w->parentWidget()->geometry();
    } else {
        qCDebug(logUtilClasses) << "using primary screen geometry";
    }

    const auto& center = parentRect.center() - w->rect().center();
    qCDebug(logUtilClasses) << "moving widget to center position:" << center;
    w->move(center);
}

QIcon getCircleIcon(const QPixmap &pixmap, int diameter)
{
    qCDebug(logUtilClasses) << "getCircleIcon called with diameter:" << diameter;
    QPixmap output(QSize(diameter, diameter));
    output.fill(Qt::transparent);
    QPainter painter(&output);
    // 抗锯齿 + 平滑边缘处理
    painter.setRenderHints(QPainter::Antialiasing, true);
    painter.setRenderHints(QPainter::SmoothPixmapTransform, true);
    painter.setPen(Qt::NoPen);

    QPainterPath path;
    path.addEllipse(0, 0, diameter, diameter);
    painter.setClipPath(path);
    painter.drawPixmap(0, 0, diameter, diameter, pixmap);
    qCDebug(logUtilClasses) << "circle icon created successfully";
    return QIcon(output);
}

QIcon getCircleIcon(const QIcon &icon, int diameter)
{
    qCDebug(logUtilClasses) << "getCircleIcon called with icon and diameter:" << diameter;
    QPixmap pixmap = icon.pixmap(QSize(diameter, diameter));
    return getCircleIcon(pixmap, diameter);
}

// 取自Qt源码qpixmapfilter.cpp 945行
void grayScale(const QImage &image, QImage &dest, const QRect &rect)
{
    qCDebug(logUtilClasses) << "grayScale called with rect:" << rect;
    QRect destRect = rect;
    QRect srcRect = rect;
    if (rect.isNull()) {
        qCDebug(logUtilClasses) << "rect is null, using full image";
        srcRect = dest.rect();
        destRect = dest.rect();
    }
    if (&image != &dest) {
        qCDebug(logUtilClasses) << "moving dest rect to origin";
        destRect.moveTo(QPoint(0, 0));
    }

    const unsigned int *data = reinterpret_cast<const unsigned int *>(image.bits());
    unsigned int *outData = reinterpret_cast<unsigned int *>(dest.bits());

    if (dest.size() == image.size() && image.rect() == srcRect) {
        qCDebug(logUtilClasses) << "using optimized grayscale loop";
        // a bit faster loop for grayscaling everything
        int pixels = dest.width() * dest.height();
        for (int i = 0; i < pixels; ++i) {
            int val = qGray(data[i]);
            outData[i] = qRgba(val, val, val, qAlpha(data[i]));
        }
    } else {
        qCDebug(logUtilClasses) << "using standard grayscale loop";
        int yd = destRect.top();
        for (int y = srcRect.top(); y <= srcRect.bottom() && y < image.height(); y++) {
            data = reinterpret_cast<const unsigned int *>(image.scanLine(y));
            outData = reinterpret_cast<unsigned int *>(dest.scanLine(yd++));
            int xd = destRect.left();
            for (int x = srcRect.left(); x <= srcRect.right() && x < image.width(); x++) {
                int val = qGray(data[x]);
                outData[xd++] = qRgba(val, val, val, qAlpha(data[x]));
            }
        }
    }
    qCDebug(logUtilClasses) << "grayscale processing completed";
}

DWIDGET_END_NAMESPACE
